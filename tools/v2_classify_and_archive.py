from __future__ import annotations

import argparse
import json
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path

from src.utils.file_access_log_v2_5_2025_11_26 import log_file_access

LEGACY_MD = Path("docs/LEGACY_CANDIDATES.md")


def load_legacy_candidates() -> set[str]:
    if not LEGACY_MD.exists():
        return set()
    candidates = set()
    for raw in LEGACY_MD.read_text(encoding="utf-8").splitlines():
        raw = raw.strip()
        if raw.startswith("- `") and raw.endswith("` (unreachable)"):
            candidates.add(raw.split("`")[1])
    return candidates


LEGACY_CANDIDATES = load_legacy_candidates()


@dataclass
class ClassificationResult:
    v2: list[str]
    v1: list[str]
    shared: list[str]
    unknown: list[str]


RULES = [
    ("src/gui/stage_cards_v2/", "v2"),
    ("src/gui/views/", ("v2",)),
    ("src/gui/views/_v2", "v2"),
    ("src/gui/views", ("unknown",)),
    ("src/gui/main_window_v2.py", "v2"),
    ("src/controller/app_controller.py", "v2"),
    ("src/gui/main_window.py", "shared"),
    ("src/gui/theme_v2.py", "v2"),
]


def classify_path(path: Path) -> str:
    rel = path.as_posix()
    if rel in LEGACY_CANDIDATES:
        return "v1"
    if rel.startswith("src/gui/stage_cards_v2/"):
        return "v2"
    if rel.startswith("src/gui/views/") and rel.endswith("_v2.py"):
        return "v2"
    if rel.startswith("src/gui/views/") and "_v2" not in rel:
        return "v1"
    if rel.startswith("src/gui/") and "_v2" not in rel:
        return "v1"
    if rel.startswith("src/controller") or rel.startswith("src/gui/main_window_v2"):
        return "v2"
    if (
        rel.startswith("src/utils")
        or rel.startswith("src/pipeline")
        or rel.startswith("src/api")
        or rel.startswith("docs")
    ):
        return "shared"
    if rel.startswith("tests/gui_v2/") and "legacy" not in rel:
        return "v2"
    if rel.startswith("tests/") and "legacy" in rel:
        return "v1"
    if rel.startswith("tests/archive") or "tests_gui_v2_legacy" in rel:
        return "v1"
    if rel.startswith("tests/journey") or "_v2" in rel:
        return "v2"
    if rel.startswith("tests/"):
        return "shared"
    return "unknown"


def walk_files(root: Path) -> Iterable[Path]:
    for path in root.rglob("*"):
        if path.is_file():
            log_file_access(path, reason="scan")
            yield path.relative_to(root)


def build_inventory(root: Path) -> ClassificationResult:
    v2, v1, shared, unknown = [], [], [], []
    for rel in walk_files(root):
        if rel.parts[0] in (".git", "archive", "logs", "runs", "__pycache__"):
            continue
        category = classify_path(rel)
        target = {"v2": v2, "v1": v1, "shared": shared, "unknown": unknown}[category]
        target.append(rel.as_posix())
    return ClassificationResult(v2=v2, v1=v1, shared=shared, unknown=unknown)


def write_json(output: Path, payload: ClassificationResult) -> None:
    output.parent.mkdir(parents=True, exist_ok=True)
    with output.open("w", encoding="utf-8") as fh:
        json.dump(payload.__dict__, fh, indent=2, sort_keys=True)


MD_TEMPLATE = """# StableNew V2 Inventory

Generated by `tools/v2_classify_and_archive.py`

## Overview

| Category | Files |
|---|---|
| V2 | {v2_count} |
| Shared | {shared_count} |
| V1 | {v1_count} |
| Unknown | {unknown_count} |

## V2 Files

{v2_list}

## Shared Files

{shared_list}

## V1 Files (potential archive candidates)

{v1_list}

## Unknown Files

{unknown_list}

"""


def format_section(name: str, entries: list[str]) -> str:
    if not entries:
        return "_none_"
    return "\n".join(f"- `{entry}`" for entry in sorted(entries))


def write_markdown(output: Path, payload: ClassificationResult) -> None:
    md = MD_TEMPLATE.format(
        v2_count=len(payload.v2),
        shared_count=len(payload.shared),
        v1_count=len(payload.v1),
        unknown_count=len(payload.unknown),
        v2_list=format_section("V2 Files", payload.v2),
        shared_list=format_section("Shared Files", payload.shared),
        v1_list=format_section("V1 Files", payload.v1),
        unknown_list=format_section("Unknown Files", payload.unknown),
    )
    output.parent.mkdir(parents=True, exist_ok=True)
    output.write_text(md, encoding="utf-8")


def main() -> None:
    parser = argparse.ArgumentParser(description="Classify V1/V2 files")
    parser.add_argument("--root", type=Path, default=Path("."), help="Repo root")
    parser.add_argument("--json", type=Path, default=Path("inventory/stable_v2_inventory.json"))
    parser.add_argument("--markdown", type=Path, default=Path("docs/StableNew_V2_Inventory.md"))
    parser.add_argument("--archive", action="store_true", help="Move V1 files into archive/")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be archived")
    parser.add_argument("--force", action="store_true", help="Skip confirmation when archiving")
    args = parser.parse_args()
    result = build_inventory(args.root)
    write_json(args.json, result)
    write_markdown(args.markdown, result)
    if args.archive:
        confirm = args.force
        if not confirm:
            resp = input("Archive V1 files to archive/? [y/N]: ").strip().lower()
            confirm = resp in {"y", "yes"}
        if confirm:
            move_to_archive(args.root, Path("archive"), result.v1, dry_run=args.dry_run)
        else:
            print("Archive cancelled.")


def _archive_target_for(rel: str, archive_root: Path) -> Path:
    if rel.startswith("src/gui/"):
        suffix = rel[len("src/gui/") :]
        return archive_root / "gui_v1" / suffix
    if rel.startswith("tests/"):
        suffix = rel[len("tests/") :]
        return archive_root / "legacy_tests" / suffix
    return archive_root / Path(rel)


def move_to_archive(
    root: Path, archive_root: Path, files: list[str], *, dry_run: bool = False
) -> None:
    if not files:
        print("No V1 files to archive.")
        return
    for rel in sorted(files):
        src = root / rel
        if not src.exists():
            continue
        target = _archive_target_for(rel, archive_root)
        target.parent.mkdir(parents=True, exist_ok=True)
        print("dry-run:" if dry_run else "moving:", rel, "->", target)
        if not dry_run:
            src.replace(target)
            log_file_access(src, reason="move")
            log_file_access(target, reason="archive")


if __name__ == "__main__":
    main()
