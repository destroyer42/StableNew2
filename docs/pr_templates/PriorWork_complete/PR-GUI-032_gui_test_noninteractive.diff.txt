PR: PR-GUI-032_gui_test_noninteractive — Make GUI tests non-interactive and resilient
NOTE: This is a guided diff. Use REPO_SNAPSHOT.md to locate the exact symbols and modules.

1) Add a GUI test mode flag

   File: src/gui/main_window.py (or a small shared GUI utils module)

   - Near the top of the file, add a small flag + helpers, e.g.:

       import os

       _FORCE_GUI_TEST_MODE = False

       def enable_gui_test_mode():
           """Explicit hook for tests to force GUI test mode."""
           global _FORCE_GUI_TEST_MODE
           _FORCE_GUI_TEST_MODE = True

       def is_gui_test_mode() -> bool:
           """Return True when running under GUI test mode."""
           return _FORCE_GUI_TEST_MODE or os.environ.get("STABLENEW_GUI_TEST_MODE") == "1"

   - If there’s already a central place for GUI flags, put these there instead and import from main_window.

2) Wrap blocking dialogs

   File: src/gui/main_window.py

   A. Unsaved / unapplied changes confirmation dialog

   - Locate the function/method that shows the “There are changes that have been made that won’t apply to any packs…” confirmation dialog, likely something like:

       def _confirm_unapplied_changes(self) -> bool:
           return messagebox.askyesno(...)

   - Change it to:

       def _confirm_unapplied_changes(self) -> bool:
           if is_gui_test_mode():
               # In tests, auto-accept so we don't block the harness.
               return True
           return messagebox.askyesno(...)

   B. “New features have been added” popup

   - Locate where the “new features have been added” / feature list dialog is shown.
     This may be:

       def _maybe_show_new_features_dialog(self):
           # existing logic...
           self._show_new_features_dialog()

   - Wrap it to skip in test mode:

       def _maybe_show_new_features_dialog(self):
           if is_gui_test_mode():
               return
           # existing logic...
           self._show_new_features_dialog()

   - If the implementation inflates a Toplevel or custom dialog directly, put the `is_gui_test_mode()` guard at the top of that code path.

3) Prevent extra main windows in tests

   File: src/gui/main_window.py (or the CLI entry point module)

   - In any `if __name__ == "__main__":` block or auto-launch path, guard with test mode:

       if __name__ == "__main__":
           from src.gui.main_window import is_gui_test_mode
           if not is_gui_test_mode():
               root = tk.Tk()
               app = MainWindow(root, ...)
               root.mainloop()

   - This ensures that importing GUI modules during tests does not spawn extra main windows that require manual closure.

4) Enable GUI test mode from tests

   File: tests/gui/conftest.py (or wherever `minimal_gui_app` is defined)

   - In the main GUI fixture used by most tests, enable test mode before constructing the main window. For example:

       @pytest.fixture
       def minimal_gui_app(monkeypatch):
           # Ensure all GUI tests run with non-interactive behavior.
           monkeypatch.setenv("STABLENEW_GUI_TEST_MODE", "1")

           from src.gui import main_window
           main_window.enable_gui_test_mode()

           # existing setup that creates root and MainWindow
           # ...
           yield app
           # teardown / root.destroy() as already implemented

   - Ensure all GUI tests import and use this fixture instead of rolling their own Tk roots.

5) Add tests for non-interactive behavior

   File: tests/gui/test_gui_test_mode.py (new) or append to an existing GUI test module

   - Add a focused test to assert that the unsaved-changes confirmation does NOT call messagebox in test mode:

       def test_unapplied_changes_confirmation_auto_accepts_in_test_mode(monkeypatch):
           from src.gui import main_window

           monkeypatch.setenv("STABLENEW_GUI_TEST_MODE", "1")
           main_window.enable_gui_test_mode()

           calls = {}

           def fake_askyesno(*args, **kwargs):
               calls["called"] = True
               return False

           # Adapt attribute path to actual import in main_window (e.g., tk.messagebox vs messagebox)
           monkeypatch.setattr(main_window.messagebox, "askyesno", fake_askyesno)

           # If _confirm_unapplied_changes is a method, construct a minimal instance;
           # otherwise adapt to actual signature.
           result = main_window.MainWindow._confirm_unapplied_changes(self=None)

           assert result is True
           assert "called" not in calls  # dialog must not be invoked in test mode

   - Add a similar test to ensure the “new features” dialog is skipped:

       def test_new_features_dialog_skipped_in_test_mode(monkeypatch):
           from src.gui import main_window

           monkeypatch.setenv("STABLENEW_GUI_TEST_MODE", "1")
           main_window.enable_gui_test_mode()

           called = {}

           def fake_show_new_features_dialog(self):
               called["hit"] = True

           monkeypatch.setattr(
               main_window.MainWindow, "_show_new_features_dialog", fake_show_new_features_dialog,
               raising=False
           )

           win = object()  # or construct a minimal MainWindow instance if required
           # Call the wrapper that decides to show or skip.
           main_window.MainWindow._maybe_show_new_features_dialog(win)

           assert "hit" not in called

   - Adapt method names and instance creation to match the real API in REPO_SNAPSHOT.md.
