# Randomizer System Spec v2  

---

## 1. Purpose

The Randomizer is a **controlled variation engine**. Its role is to:

- Generate tasteful, deterministic variations of a strong base config.
- Work seamlessly with the learning system and pipeline runner.
- Provide a clear UX for “How many variants am I about to generate?” and “What is changing?”

Randomizer is **not** responsible for discovering good baseline configs; that is the job of the **Learning System** and the operator’s judgment. Randomizer explores variety once a configuration is reasonably “locked in.”

---

## 2. Concepts

- **Matrix fields** – prompt tokens or config fields that can take multiple values (e.g., style tokens, LoRAs, color themes).
- **Modes**
  - **Off** – no randomization, single run.
  - **Sequential** – iterate through all combinations in a fixed order.
  - **Rotate** – rotate through combinations across calls, cycling deterministically.
  - **Random** – randomized selection with a stable seed.

- **Fanout** – number of images per matrix combination (e.g., 2 images per variant).
- **Variant Plan** – list of planned variants, each describing:
  - Which matrix values to use for this variant.
  - Any other config overlays.

---

## 3. Data Flow

1. User sets matrix fields and mode in **RandomizerPanelV2**.
2. RandomizerPanelV2 exposes **options dict** to the controller via **RandomizerAdapter**.
3. RandomizerAdapter:
   - Computes the variant plan using the core randomizer utilities.
   - Computes **variant_count** for preview.
   - Provides a function to apply each variant’s overlay onto a base PipelineConfig.

4. Controller and PipelineRunner:
   - Decide whether to execute all variants or just the first one (current behavior is “first variant only” with a TODO for multi‑variant execution).
   - Future: wrap the plan into a **multi‑job pipeline**.

---

## 4. RandomizerPanelV2 Behavior

- Fields:
  - Mode: [Off, Sequential, Rotate, Random].
  - Matrix fields: likely text entries/controls for:
    - Styles / prompt fragments.
    - LoRA names/weights.
    - Embeddings.
  - Fanout (int).
- Derived:
  - “Total variants” label (num_matrix_combinations * fanout).

- Requirements:
  - Any change in matrix fields, mode, or fanout immediately updates the variant count via adapter.
  - Validation ensures that insane variant counts (e.g., thousands) are flagged or disallowed for interactive runs.

---

## 5. Core Randomizer Semantics

### 5.1 Matrix Expansion

- Given several matrix dimensions (e.g., style, color, camera), the core randomizer expands to all combinations.
- For example, 2 styles × 3 colors × 2 cameras = 12 matrix combinations.

- Modes:
  - **Sequential**: iterate in fixed order every time.
  - **Rotate**: maintain a rotation index across calls, so repeated runs cycle through the combinations.
  - **Random**: shuffle combinations using a seed, but remain reproducible when the seed is fixed.

### 5.2 Fanout

- For each matrix combination, fanout determines how many images to generate.
- The variant plan size is `len(combos) * fanout`.
- Fanout is always considered in the **variant count preview**.

### 5.3 Config Overlay

- The randomizer never mutates the base config directly.
- Instead, it generates a list of **overlays** that are applied on top of the base PipelineConfig (e.g., extra prompt text, LoRA names, weights).
- This ensures that:
  - LearningRecords always see the full effective config each variant used.
  - The base config can be reused unchanged for future runs.

---

## 6. Integration with Learning

Randomizer and Learning must cooperate cleanly:

- Learning requires clear documentation of what changed for each variant.
- Each variant generated by the randomizer should be traceable in LearningRecords via:
  - matrix values used.
  - variant index.
  - relationship to base config.

**Best practice**:

- Use Learning to lock in strong settings for steps, CFG, sampler, scheduler, etc.
- Use Randomizer primarily for stylistic axes:
  - style tokens, LoRAs, embeddings, camera tags, etc.
- When using Randomizer for core settings (e.g., CFG, steps), ensure experiments are still understandable and limited in size.

---

## 7. Cluster‑Aware Considerations

In a cluster environment:

- A **variant plan** can be treated as a list of jobs for scheduling.
- Each variant becomes a job submitted to the **queue manager**.
- The queue manager can then:
  - Spread variants across nodes (higher throughput).
  - Group variants by cost (e.g., high‑resolution variants go to the strongest GPU).

Learning ensures that after large randomized batches, the user’s ratings feed back into better presets for future one‑click runs.

---

## 8. Testing Expectations

- Core randomizer:
  - Matrix parsing.
  - Mode semantics (sequential, rotate, random).
  - Fanout correctness.
  - Parity between preview and pipeline plans.

- RandomizerAdapter:
  - Correct computation of variant count.
  - Stable behavior when panel options change.
  - No GUI imports.

- GUI V2 tests:
  - RandomizerPanelV2 wiring (variant count label updates).
  - Basic load/save of randomizer settings with prompt pack configs.
